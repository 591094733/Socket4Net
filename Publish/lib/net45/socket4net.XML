<?xml version="1.0"?>
<doc>
    <assembly>
        <name>socket4net</name>
    </assembly>
    <members>
        <member name="T:socket4net.objects.ObjWrapperArg`1">
            <summary>
                arg
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.objects.ObjWrapperArg`1.#ctor(socket4net.IObj,`0)">
            <summary>
            
            </summary>
            <param name="owner"></param>
            <param name="obj"></param>
        </member>
        <member name="P:socket4net.objects.ObjWrapperArg`1.Object">
            <summary>
            
            </summary>
        </member>
        <member name="T:socket4net.objects.ObjWrapper`1">
            <summary>
                object wrapper
                make any object schedulable
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:socket4net.objects.ObjWrapper`1.Object">
            <summary>
                underline object
            </summary>
        </member>
        <member name="M:socket4net.objects.ObjWrapper`1.OnInit(socket4net.ObjArg)">
            <summary>
               internal called when an Obj is initialized
            </summary>
            <param name="arg"></param>
        </member>
        <member name="T:socket4net.ERpc">
            <summary>
                rpc type
            </summary>
        </member>
        <member name="F:socket4net.ERpc.Push">
            <summary>
                notify
                needn't an response
            </summary>
        </member>
        <member name="F:socket4net.ERpc.Request">
            <summary>
                request
                response needed
            </summary>
        </member>
        <member name="F:socket4net.ERpc.Response">
            <summary>
                response
                used internal
            </summary>
        </member>
        <member name="T:socket4net.RpcResult">
            <summary>
                
            </summary>
        </member>
        <member name="M:socket4net.RpcResult.#ctor(System.Boolean,System.Byte[])">
            <summary>
            
            </summary>
            <param name="item1"></param>
            <param name="item2"></param>
        </member>
        <member name="M:socket4net.RpcResult.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:socket4net.RpcResult.op_Implicit(socket4net.RpcResult)~System.Boolean">
            <summary>
            
            </summary>
            <param name="rt"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.RpcResult.op_Implicit(System.Boolean)~socket4net.RpcResult">
            <summary>
            
            </summary>
            <param name="ret"></param>
            <returns></returns>
        </member>
        <member name="P:socket4net.RpcResult.Success">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.RpcResult.Failure">
            <summary>
            
            </summary>
        </member>
        <member name="M:socket4net.RpcResult.MakeSuccess(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.RpcResult.MakeSuccess``1(``0)">
            <summary>
            
            </summary>
            <param name="proto"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.RpcResult.MakeFailure``1(``0)">
            <summary>
            
            </summary>
            <param name="proto"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:socket4net.Obj">
            <summary>
                对象基类
            </summary>
        </member>
        <member name="F:socket4net.Obj.MillisecondsPerDay">
            <summary>
                
            </summary>
        </member>
        <member name="M:socket4net.Obj.OnInit(socket4net.ObjArg)">
            <summary>
               internal called when an Obj is initialized
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:socket4net.Obj.OnDestroy">
            <summary>
               internal called when an Obj is to be destroyed
            </summary>
        </member>
        <member name="M:socket4net.Obj.ClearTimers">
            <summary>
                clear timers attached on this obj
            </summary>
        </member>
        <member name="M:socket4net.Obj.InvokeRepeating(System.Action,System.UInt32,System.UInt32)">
            <summary>
                Excute 'action' after 'delay' ms for every 'period' ms
            </summary>
        </member>
        <member name="M:socket4net.Obj.Invoke(System.Action,System.UInt32)">
            <summary>
                Excute 'action' after 'delay' ms
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="M:socket4net.Obj.Invoke(System.Action,System.DateTime)">
            <summary>
                Excute 'action' when 'when'
            </summary>
            <param name="action"></param>
            <param name="when"></param>
        </member>
        <member name="M:socket4net.Obj.Invoke(System.Action,System.Int32,System.Int32,System.Int32)">
            <summary>
                Excute 'action' every 'hour:min:s'
            </summary>
            <param name="action"></param>
            <param name="hour"></param>
            <param name="min"></param>
            <param name="s"></param>
        </member>
        <member name="M:socket4net.Obj.Invoke(System.Action,System.TimeSpan)">
            <summary>
                Excute 'action' everyday's 'time' clock
            </summary>
            <param name="action"></param>
            <param name="time"></param>
        </member>
        <member name="M:socket4net.Obj.CancelInvoke(System.Action)">
            <summary>
                取消action的调度
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.Obj.InvokeAsync(System.Action,System.TimeSpan[])">
            <summary>
                每日的times时间点执行action
            </summary>
            
        </member>
        <member name="M:socket4net.Obj.InvokeAsync(System.Action,System.DateTime[])">
            <summary>
                在whens指定的时间点执行action
            </summary>
        </member>
        <member name="M:socket4net.Obj.InvokeAsync(System.Action,System.TimeSpan)">
            <summary>
                Excute 'action' everyday's 'time' clock
            </summary>
            <param name="action"></param>
            <param name="time"></param>
        </member>
        <member name="M:socket4net.Obj.InvokeAsync(System.Action,System.DateTime)">
            <summary>
                Excute 'action' when 'when'
            </summary>
            <param name="action"></param>
            <param name="when"></param>
        </member>
        <member name="M:socket4net.Obj.InvokeAsync(System.Action,System.UInt32)">
            <summary>
                Excute 'action' after 'delay' ms
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="P:socket4net.Obj.socket4net#IObj#InstanceId">
            <summary>
                Obj instance id
                Unique only before current process dead
            </summary>
        </member>
        <member name="P:socket4net.Obj.Name">
            <summary>
                name
            </summary>
        </member>
        <member name="P:socket4net.Obj.Priority">
            <summary>
                Schedule priority
                Just like Unity's layer
            </summary>
        </member>
        <member name="M:socket4net.Obj.#ctor">
            <summary>
                Constructor
                InstanceId is assigned here
            </summary>
        </member>
        <member name="P:socket4net.Obj.Owner">
            <summary>
                Owner
            </summary>
        </member>
        <member name="P:socket4net.Obj.OwnerDescription">
            <summary>
                Owner description
            </summary>
        </member>
        <member name="P:socket4net.Obj.Initialized">
            <summary>
                If initialized
            </summary>
        </member>
        <member name="P:socket4net.Obj.Started">
            <summary>
                If started
            </summary>
        </member>
        <member name="P:socket4net.Obj.Destroyed">
            <summary>
                If destroyed
            </summary>
        </member>
        <member name="P:socket4net.Obj.Fresh">
            <summary>
                If IObj's 'Born' invoked 
            </summary>
        </member>
        <member name="M:socket4net.Obj.CompareTo(socket4net.IObj)">
            <summary>
                comparer
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Obj.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:socket4net.Obj.Init(socket4net.ObjArg)">
            <summary>
                Initialize
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:socket4net.Obj.Start">
            <summary>
                Run
            </summary>
        </member>
        <member name="M:socket4net.Obj.OnStart">
            <summary>
                Invoked when obj started
            </summary>
        </member>
        <member name="M:socket4net.Obj.Destroy">
            <summary>
                Destroy
            </summary>
        </member>
        <member name="M:socket4net.Obj.Born">
            <summary>
                Born
                Obj only born once during it's life circle
            </summary>
        </member>
        <member name="M:socket4net.Obj.OnBorn">
            <summary>
                Invoked when obj born
            </summary>
        </member>
        <member name="M:socket4net.Obj.GetAncestor``1">
            <summary>
                Get obj's ancestor
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.Obj.Create(System.Type,socket4net.ObjArg,System.Boolean)">
            <summary>
                create object of type "type"
            </summary>
            <param name="type"></param>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Obj.Create``1(socket4net.ObjArg,System.Boolean)">
            <summary>
                create object of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Obj.ClearCtorCache">
            <summary>
                clear the constructors cache
            </summary>
        </member>
        <member name="T:socket4net.SlicedObj">
            <summary>
                sliced object
            </summary>
        </member>
        <member name="E:socket4net.SlicedObj.EventProgressChanged">
            <summary>
                event raised when progress changed
            </summary>
        </member>
        <member name="E:socket4net.SlicedObj.EventFailed">
            <summary>
                event raised when process failed
            </summary>
        </member>
        <member name="E:socket4net.SlicedObj.EventCompleted">
            <summary>
                event raised when process completed
            </summary>
        </member>
        <member name="P:socket4net.SlicedObj.Percent">
            <summary>
               get process percentage
            </summary>
        </member>
        <member name="P:socket4net.SlicedObj.Progress">
            <summary>
                get process progress
            </summary>
        </member>
        <member name="P:socket4net.SlicedObj.Steps">
            <summary>
                get sliced steps
            </summary>
        </member>
        <member name="P:socket4net.SlicedObj.IsDone">
            <summary>
                specify wether processing is done
            </summary>
        </member>
        <member name="P:socket4net.SlicedObj.Failed">
            <summary>
                specify wether processing is failed
            </summary>
        </member>
        <member name="M:socket4net.SlicedObj.OnDestroy">
            <summary>
               internal called when an Obj is to be destroyed
            </summary>
        </member>
        <member name="T:socket4net.IDataProtocol">
            <summary>
                data transform protocol
            </summary>
        </member>
        <member name="T:socket4net.DefaultDataProtocol">
            <summary>
            socket4net's default data protocol
            </summary>
        </member>
        <member name="P:socket4net.DefaultDataProtocol.Ops">
            <summary>
                operation id
            </summary>
        </member>
        <member name="P:socket4net.DefaultDataProtocol.Data">
            <summary>
                operation data
            </summary>
        </member>
        <member name="M:socket4net.DefaultDataProtocol.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:socket4net.BatchedScheduler">
            <summary>
                Batch定时器调度器
            </summary>
        </member>
        <member name="M:socket4net.BatchedScheduler.#ctor(socket4net.IFlushable)">
            <summary>
            
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:socket4net.BatchedScheduler.InvokeRepeatingImp(System.Action,System.UInt32,System.UInt32)">
            <summary>
                Internal invoker for Obj
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
            <param name="period"></param>
        </member>
        <member name="M:socket4net.BatchedScheduler.InvokeImp(System.Action,System.UInt32)">
            <summary>
                Internal invoker for Obj
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="T:socket4net.IFlushable">
            <summary>
                interface of flushable object
            </summary>
        </member>
        <member name="M:socket4net.IFlushable.Flush">
            <summary>
                do flush operations
            </summary>
        </member>
        <member name="T:socket4net.Flusher">
            <summary>
               auto flush in an "using" statement
            </summary>
        </member>
        <member name="M:socket4net.Flusher.#ctor(socket4net.IFlushable)">
            <summary>
            
            </summary>
            <param name="target"></param>
        </member>
        <member name="T:socket4net.Scheduler">
            <summary>
                action scheduler
            </summary>
        </member>
        <member name="M:socket4net.Scheduler.AddTimer(System.Action,socket4net.TimerWrapper)">
            <summary>
                add action 
                used internal
            </summary>
            <param name="action"></param>
            <param name="aw"></param>
        </member>
        <member name="M:socket4net.Scheduler.OnDestroy">
            <summary>
               internal called when an Obj is to be destroyed
            </summary>
        </member>
        <member name="M:socket4net.Scheduler.Clear">
            <summary>
                clear the timers maintained by me
            </summary>
        </member>
        <member name="M:socket4net.Scheduler.InvokeRepeatingImp(System.Action,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
            <param name="period"></param>
        </member>
        <member name="M:socket4net.Scheduler.InvokeImp(System.Action,System.UInt32)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="M:socket4net.Scheduler.CancelInvokeImp(System.Action)">
            <summary>
                
            </summary>
            <param name="action"></param>
        </member>
        <member name="T:socket4net.Timer">
            <summary>
            A timer class base on Linux style timer scheduler.
            </summary>
        </member>
        <member name="M:socket4net.Timer.#ctor(System.String,System.UInt32,System.UInt32)">
            <summary>
            Construct a new timer object.
            </summary>
            <param name="name">the timer's name</param>
            <param name="dueTime">when to begin this timer, in milliseconds.
            zero means start immediately</param>
            <param name="period">the period of this timer, , in milliseconds.
            zero means the timer is schedule once only</param>
        </member>
        <member name="M:socket4net.Timer.#ctor(System.String,System.UInt32)">
            <summary>
            Construct a new timer object.
            </summary>
            <param name="name">the timer's name</param>
            <param name="dueTime">when to begin this timer, in milliseconds.
            zero means start immediately</param>
        </member>
        <member name="P:socket4net.Timer.Name">
            <summary>
            Time's name
            </summary>
        </member>
        <member name="P:socket4net.Timer.DueTime">
            <summary>
            When to start the timer, in milliseconds.
            </summary>
        </member>
        <member name="P:socket4net.Timer.Period">
            <summary>
            The timer period, in milliseconds.
            </summary>
        </member>
        <member name="P:socket4net.Timer.IsPeriod">
            <summary>
            Indicate it's a period timer or not.
            </summary>
        </member>
        <member name="M:socket4net.Timer.Trigger">
            <summary>
            Call the timer's callback events.
            This method is called by <c>TimerScheduler</c> class only.
            </summary>
        </member>
        <member name="P:socket4net.Timer.IsStarted">
            <summary>
            Indicate whether the timer is start or not.
            </summary>
        </member>
        <member name="P:socket4net.Timer.State">
            <summary>
            User define parameter.
            </summary>
        </member>
        <member name="P:socket4net.Timer.Expires">
            <summary>
            The expire time.
            this property only be used by <c>TimerScheduler</c> class.
            </summary>
        </member>
        <member name="P:socket4net.Timer.Entry">
            <summary>
            When timer is started, it's put in queue, this property is
            the queue entry for this timer object.
            this property only be used by <c>TimerScheduler</c> class.
            </summary>
        </member>
        <member name="E:socket4net.Timer.Arrived">
            <summary>
            When timer is trigger, this event will be called.
            </summary>
        </member>
        <member name="M:socket4net.Timer.Start">
            <summary>
            Start the timer.
            </summary>
        </member>
        <member name="M:socket4net.Timer.Stop">
            <summary>
            Stop the timer.
            </summary>
        </member>
        <member name="T:socket4net.QueueEntry">
            <summary>
            Queue entry class
            </summary>
        </member>
        <member name="M:socket4net.QueueEntry.#ctor(socket4net.Timer)">
            <summary>
            Construct a new entry object with a timer object.
            </summary>
            <param name="t">a non-null timer object</param>
        </member>
        <member name="M:socket4net.QueueEntry.#ctor">
            <summary>
            Construct a new head entry. That is, it's Prev/Next properties
            are point to itself.
            </summary>
        </member>
        <member name="P:socket4net.QueueEntry.Prev">
            <summary>
            The Preview entry object
            </summary>
        </member>
        <member name="P:socket4net.QueueEntry.Next">
            <summary>
            The next entry object
            </summary>
        </member>
        <member name="P:socket4net.QueueEntry.Timer">
            <summary>
            The timer object
            </summary>
        </member>
        <member name="M:socket4net.QueueEntry.QueueTail(socket4net.QueueEntry)">
            <summary>
            Queue the entry object into a queue specify by 'h'
            </summary>
            <param name="h">the entry object, must be a head entry object</param>
        </member>
        <member name="M:socket4net.QueueEntry.DeQueue">
            <summary>
            Dequeue the entry object
            </summary>
        </member>
        <member name="M:socket4net.QueueEntry.Discard">
            <summary>
            UnBinding the timer object
            </summary>
        </member>
        <member name="T:socket4net.TimerConstant">
            <summary>
            Define the constant variable used by <c>TimerScheduler</c> class
            </summary>
        </member>
        <member name="T:socket4net.Tvn">
            <summary>
            Timer vector class.
            </summary>
        </member>
        <member name="T:socket4net.Tvr">
            <summary>
            Timer vector class.
            It's a specific type of <c>TVN</c>, it's vector size
            is different from <c>TVN</c>.
            </summary>
        </member>
        <member name="T:socket4net.TimerScheduler">
            <summary>
            A Linux style timer scheduler
            </summary>
        </member>
        <member name="P:socket4net.TimerScheduler.HostService">
            <summary>
            get the logic service where this scheduler hosted
            </summary>
        </member>
        <member name="M:socket4net.TimerScheduler.#ctor(socket4net.Service)">
            <summary>
            
            </summary>
            <param name="service"></param>
        </member>
        <member name="M:socket4net.TimerScheduler.Dispose">
            <summary>执行与释放或重置非托管资源相关的应用程序定义的任务。</summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:socket4net.TimerScheduler._timerJiffies">
            <summary>
            This field used to store how many milliseconds
            elapsed since this scheduler been constructed.
            All timer's expire time is calculated base on this field.
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._runningTimer">
            <summary>
            When scheduler is trigger a timer, this field store the timer object.
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._tv1">
            <summary>
            The first class of timers vector, their expire time will less than 256 milliseconds.
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._tv2">
            <summary>
            The second class of timers vector, their expire time will grater than 255 milliseconds
            and less than 16384(1 left shit 14) milliseconds
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._tv3">
            <summary>
            The second class of timers vector, their expire time will grater than 16384 milliseconds
            and less than 1048576(1 left shit 20) milliseconds
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._tv4">
            <summary>
            The second class of timers vector, their expire time will grater than 1048576 milliseconds
            and less than 67108864(1 left shit 26) milliseconds
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._tv5">
            <summary>
            The second class of timers vector, their expire time will grater than 67108864 milliseconds
            and less than uint.Max(1 left shit 32) milliseconds
            if the expires is grater then uint.Max, it will be truncated.
            </summary>
        </member>
        <member name="M:socket4net.TimerScheduler.RunTimer">
            <summary>
            <c>Service</c>'s Idle event call this method
            to check all expired timers.
            </summary>
        </member>
        <member name="M:socket4net.TimerScheduler.Add(socket4net.Timer)">
            <summary>
            Put a timer object in scheduler's queue.
            </summary>
            <param name="t">the timer object</param>
        </member>
        <member name="M:socket4net.TimerScheduler.Remove(socket4net.Timer)">
            <summary>
            remove a timer object from scheduler's queue.
            </summary>
            <param name="t">the timer object</param>
        </member>
        <member name="M:socket4net.TimerScheduler.Cascade(socket4net.Tvn,System.Int32)">
            <summary>
            Cascade a timers vector
            </summary>
            <param name="tv">the timers vector</param>
            <param name="index">which queue to cascade</param>
            <returns></returns>
        </member>
        <member name="M:socket4net.TimerScheduler.Cascade">
            <summary>
            Cascade all timers vectors
            </summary>
        </member>
        <member name="M:socket4net.TimerScheduler.InternalAdd(socket4net.QueueEntry)">
            <summary>
            Queue an entry object into a suitable timer queue.
            </summary>
            <param name="e">the entry object</param>
        </member>
        <member name="T:socket4net.TimerWrapper">
            <summary>
                wrap action with parameters
            </summary>
        </member>
        <member name="M:socket4net.TimerWrapper.New(System.String,System.Action,System.UInt32)">
            <summary>
                
            </summary>
            <param name="name"></param>
            <param name="action"></param>
            <param name="duetime"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.TimerWrapper.New(System.String,System.Action,System.UInt32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="action"></param>
            <param name="duetime"></param>
            <param name="period"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.TimerWrapper.Start">
            <summary>
            
            </summary>
        </member>
        <member name="M:socket4net.TimerWrapper.Stop">
            <summary>
            
            </summary>
        </member>
        <member name="T:socket4net.PerformanceMonitor">
            <summary>
                performance monitor
            </summary>
        </member>
        <member name="P:socket4net.PerformanceMonitor.Ins">
            <summary>
                get performance monitor singlton instance
            </summary>
        </member>
        <member name="P:socket4net.PerformanceMonitor.RefreshPeriod">
            <summary>
                refresh record every "RefreshPeriod" second
            </summary>
        </member>
        <member name="F:socket4net.PerformanceMonitor.ExcutedJobsPerSec">
            <summary>
                excuted sta service jobs count per second
            </summary>
        </member>
        <member name="F:socket4net.PerformanceMonitor.ReadBytesPerSec">
            <summary>
            
            </summary>
        </member>
        <member name="F:socket4net.PerformanceMonitor.WriteBytesPerSec">
            <summary>
            
            </summary>
        </member>
        <member name="F:socket4net.PerformanceMonitor.ReadPackagesPerSec">
            <summary>
            
            </summary>
        </member>
        <member name="F:socket4net.PerformanceMonitor.WritePackagesPerSec">
            <summary>
            
            </summary>
        </member>
        <member name="M:socket4net.PerformanceMonitor.OnStart">
            <summary>
                Invoked when obj started
            </summary>
        </member>
        <member name="M:socket4net.PerformanceMonitor.RecordRead(System.Int32)">
            <summary>
            
            </summary>
            <param name="len"></param>
        </member>
        <member name="M:socket4net.PerformanceMonitor.RecordWrite(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="len"></param>
            <param name="packages"></param>
        </member>
        <member name="M:socket4net.PerformanceMonitor.RecordJob">
            <summary>
            
            </summary>
        </member>
        <member name="T:socket4net.Service">
            <summary>
                service
                1、provide single thread excution environment
                2、schedule timer and coroutine
            </summary>
        </member>
        <member name="F:socket4net.Service._workingThread">
            <summary>
                underline working thread
            </summary>
        </member>
        <member name="F:socket4net.Service._workingQueue">
            <summary>
                working queue
            </summary>
        </member>
        <member name="P:socket4net.Service.Scheduler">
            <summary>
                timer scheduler
            </summary>
        </member>
        <member name="P:socket4net.Service.CoroutineScheduler">
            <summary>
                coroutine scheduler
            </summary>
        </member>
        <member name="E:socket4net.Service.Idle">
            <summary>
                Idle event, call by working thread
                every period.
                <remarks>
                    generally the working thread
                    call the event every period, but if it's too busy
                    because the working item consumes too much time,
                    the calling period may grater than the original period
                </remarks>
            </summary>
        </member>
        <member name="P:socket4net.Service.QueueCapacity">
            <summary>
                Specify the capacity of the working item queue.
                <remarks>
                    when the items count in working queue reach the capacity
                    of the queue, all producer will block until there is one or more slot being free
                </remarks>
            </summary>
        </member>
        <member name="P:socket4net.Service.Period">
            <summary>
                Specify the working period of the working thread in milliseconds.
                That is, every period,the working thread loop back to the working
                procedure's top. and, the Idle event is called.
            </summary>
        </member>
        <member name="P:socket4net.Service.WiElapsed">
            <summary>
                A time counter that count the work items consume how much time
                in one working thread's loop. It maybe grater than the working period,
                which indicates the work items consume too much time.
            </summary>
        </member>
        <member name="P:socket4net.Service.IdleCallbackElapsed">
            <summary>
                A time counter that count the Idle event callbacks consume how much
                time in one working thread's loop. This value should be less than period.
            </summary>
        </member>
        <member name="P:socket4net.Service.ElapsedMilliseconds">
            <summary>
                Get the elapsed milliseconds since the instance been constructed
            </summary>
        </member>
        <member name="M:socket4net.Service.Perform(System.Action)">
            <summary>
                excute
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.Service.Perform``1(System.Action{``0},``0)">
            <summary>
                excute action produced by other threads
            </summary>
            <param name="action"></param>
            <param name="param"></param>
        </member>
        <member name="M:socket4net.Service.Perform(System.Func{System.Threading.Tasks.Task{socket4net.RpcResult}})">
            <summary>
                异步执行
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.Service.OnStart">
            <summary>
                Invoked when obj started
            </summary>
        </member>
        <member name="M:socket4net.Service.OnDestroy">
            <summary>
                internal called when an Obj is to be destroyed
            </summary>
        </member>
        <member name="P:socket4net.Service.Jobs">
            <summary>
                Specify the work items count currently in working queue.
            </summary>
        </member>
        <member name="M:socket4net.Service.WorkingProcedure">
            <summary>
                working thread's working procedure
            </summary>
        </member>
        <member name="T:socket4net.WebsocketClientArg">
            <summary>
            </summary>
        </member>
        <member name="M:socket4net.WebsocketClientArg.#ctor(socket4net.IObj,System.String,System.String)">
            <summary>
            </summary>
            <param name="owner"></param>
            <param name="key"></param>
            <param name="url"></param>
        </member>
        <member name="P:socket4net.WebsocketClientArg.Url">
            <summary>
            </summary>
        </member>
        <member name="T:socket4net.WebsocketClient">
            <summary>
                websocket client
            </summary>
        </member>
        <member name="F:socket4net.WebsocketClient._websocket">
            <summary>
                underline websocket
            </summary>
        </member>
        <member name="P:socket4net.WebsocketClient.Connected">
            <summary>
                specify if connection is alive
            </summary>
        </member>
        <member name="M:socket4net.WebsocketClient.Close">
            <summary>
                close session
            </summary>
        </member>
        <member name="M:socket4net.WebsocketClient.SendAsync(System.Byte[],System.Action{System.Boolean})">
            <summary>
                send async
            </summary>
            <param name="bytes"></param>
            <param name="cb"></param>
        </member>
        <member name="M:socket4net.WebsocketClient.Send(System.Byte[])">
            <summary>
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:socket4net.WebsocketClient.OnRequest(socket4net.IDataProtocol)">
            <summary>
                handle request
            </summary>
            <param name="rq"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketClient.OnPush(socket4net.IDataProtocol)">
            <summary>
                handle push
            </summary>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="E:socket4net.WebsocketClient.OnClose">
            <summary>
                Occurs when the WebSocket connection has been closed.
            </summary>
        </member>
        <member name="E:socket4net.WebsocketClient.OnError">
            <summary>
                Occurs when the <see cref="T:WebSocketSharp.WebSocket" /> gets an error.
            </summary>
        </member>
        <member name="E:socket4net.WebsocketClient.OnMessage">
            <summary>
                Occurs when the <see cref="T:WebSocketSharp.WebSocket" /> receives a message.
            </summary>
        </member>
        <member name="E:socket4net.WebsocketClient.OnOpen">
            <summary>
                Occurs when the WebSocket connection has been established.
            </summary>
        </member>
        <member name="M:socket4net.WebsocketClient.OnInit(socket4net.ObjArg)">
            <summary>
                internal called when an Obj is initialized
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:socket4net.WebsocketClient.MessageHandler(System.Object,WebSocketSharp.MessageEventArgs)">
            <summary>
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:socket4net.WebsocketClient.OnDestroy">
            <summary>
                internal called when an Obj is to be destroyed
            </summary>
        </member>
        <member name="M:socket4net.WebsocketClient.ConnectAsync">
            <summary>
            </summary>
        </member>
        <member name="M:socket4net.WebsocketClient.RequestAsync``1(``0)">
            <summary>
                request an data protocol asynchronous
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketClient.RequestAsync``1(``0,System.Action{System.Boolean,System.Byte[]})">
            <summary>
            </summary>
            <param name="proto"></param>
            <param name="cb"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.WebsocketClient.Push``1(``0)">
            <summary>
            </summary>
            <param name="proto"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:socket4net.WebsocketSession">
            <summary>
                websocket session abstraction
            </summary>
        </member>
        <member name="M:socket4net.WebsocketSession.OnMessage(WebSocketSharp.MessageEventArgs)">
            <summary>
                Called when the <see cref="T:WebSocketSharp.WebSocket" /> used in the current session receives a message.
            </summary>
            <param name="e">
                A <see cref="T:WebSocketSharp.MessageEventArgs" /> that represents the event data passed to
                a <see cref="!:WebSocket.OnMessage" /> event.
            </param>
        </member>
        <member name="M:socket4net.WebsocketSession.OnError(WebSocketSharp.ErrorEventArgs)">
            <summary>
                Called when the <see cref="T:WebSocketSharp.WebSocket" /> used in a session gets an error.
            </summary>
            <param name="e">
                A <see cref="T:WebSocketSharp.ErrorEventArgs" /> that represents the event data passed to
                a <see cref="E:WebSocketSharp.WebSocket.OnError" /> event.
            </param>
        </member>
        <member name="M:socket4net.WebsocketSession.OnOpen">
            <summary>
            Called when the WebSocket connection used in a session has been established.
            </summary>
        </member>
        <member name="M:socket4net.WebsocketSession.OnClose(WebSocketSharp.CloseEventArgs)">
            <summary>
            Called when the WebSocket connection used in a session has been closed.
            </summary>
            <param name="e">
            A <see cref="T:WebSocketSharp.CloseEventArgs"/> that represents the event data passed to
            a <see cref="E:WebSocketSharp.WebSocket.OnClose"/> event.
            </param>
        </member>
        <member name="M:socket4net.WebsocketSession.OnMessage(System.String)">
            <summary>
                string handler
            </summary>
            <param name="data"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:socket4net.WebsocketSession.BroadcastAsync(System.Byte[],System.Action)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="cb"></param>
        </member>
        <member name="M:socket4net.WebsocketSession.BroadcastAsync(System.Byte[])">
            <summary>
                asynchronous broadcast bytes
                thread safe
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketSession.BroadcastAsync``1(``0)">
            <summary>
                asynchronous broadcast a proto
            </summary>
            <param name="proto"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketSession.SendAsync(System.Byte[])">
            <summary>
                send bytes asynchronous
                thread safe
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketSession.socket4net#IWebsocketDelegateHost#SendAsync(System.Byte[],System.Action{System.Boolean})">
            <summary>
                explicit implementation
            </summary>
            <param name="data"></param>
            <param name="cb"></param>
        </member>
        <member name="M:socket4net.WebsocketSession.socket4net#IWebsocketDelegateHost#Send(System.Byte[])">
            <summary>
                explicit implementation
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:socket4net.WebsocketSession.Close">
            <summary>
                close session
            </summary>
        </member>
        <member name="M:socket4net.WebsocketSession.OnRequest(socket4net.IDataProtocol)">
            <summary>
                handle request
            </summary>
            <param name="rq"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketSession.OnPush(socket4net.IDataProtocol)">
            <summary>
                handle push
            </summary>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketSession.MultiCast``1(``0,System.Collections.Generic.IEnumerable{socket4net.WebsocketSession})">
            <summary>
                multicast
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
            <param name="sessions"></param>
        </member>
        <member name="M:socket4net.WebsocketSession.RequestAsync``1(``0)">
            <summary>
                request an data protocol asynchronous
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketSession.RequestAsync``1(``0,System.Action{System.Boolean,System.Byte[]})">
            <summary>
            </summary>
            <param name="proto"></param>
            <param name="cb"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.WebsocketSession.Push``1(``0)">
            <summary>
            </summary>
            <param name="proto"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:socket4net.Assert">
            <summary>
                断言
            </summary>
        </member>
        <member name="M:socket4net.Assert.NotNull``1(``0,System.String)">
            <summary>
                保证目标非空，否则抛出异常
            </summary>
            <param name="input"></param>
            <param name="msg"></param>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:socket4net.Assert.IsTrue(System.Boolean,System.String)">
            <summary>
                保证目标为true，否则抛出异常
            </summary>
            <param name="boolean"></param>
            <param name="msg"></param>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:socket4net.Assert.ThrowIf(System.Boolean,System.String)">
            <summary>
                若目标表达式为true，则抛出异常
            </summary>
            <param name="boolean"></param>
            <param name="msg"></param>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:socket4net.Assert.ThrowIfNot(System.Boolean,System.String)">
            <summary>
                若目标表达式非true，则抛出异常
            </summary>
            <param name="boolean"></param>
            <param name="msg"></param>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="T:socket4net.IParsableFromString">
            <summary>
                
            </summary>
        </member>
        <member name="T:socket4net.Convertor">
            <summary>
            
            </summary>
        </member>
        <member name="M:socket4net.Convertor.GetDefault(System.Type)">
            <summary>
                get default value for type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Convertor.MakeEmptyList(System.Type)">
            <summary>
                get an empty list
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Convertor.To``1(System.String)">
            <summary>
                generic parse an object from string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Convertor.To(System.String,System.Type)">
            <summary>
                non-generic convertor
            </summary>
            <param name="str"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Convertor.ToList``1(System.String,System.Char[])">
            <summary>
                parse string to list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Convertor.ToList(System.String,System.Type,System.Char[])">
            <summary>
                parse string to list
            </summary>
            <param name="strInput"></param>
            <param name="type"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.DictionaryExt">
            <summary>
                extension for dictionary
            </summary>
        </member>
        <member name="M:socket4net.DictionaryExt.NextValue``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
                随机获取字典的值
            </summary>
            <param name="input"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.NextPair``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
                随机获取字典的键值对
            </summary>
            <param name="input"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:socket4net.DictionaryExt.IsNullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
                字典是否为空
            </summary>
            <param name="input"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.GetOrReturnDefault``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
                获取字典的值，若不存在则返回默认值（值类型默认值）
            </summary>
            <param name="input"></param>
            <param name="key"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.ToListPair``1(System.Collections.Generic.Dictionary{``0,``0})">
            <summary>
                将字典转成对列表
            </summary>
            <param name="input"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.ToList``1(System.Collections.Generic.Dictionary{``0,``0})">
            <summary>
                将字典转成列表（键值依次展开）
            </summary>
            <param name="input"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.Get``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
                获取字典指定键对应的值
            </summary>
            <param name="input"></param>
            <param name="key"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:socket4net.DictionaryExt.Set``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
                设置键值
            </summary>
            <param name="input"></param>
            <param name="key"></param>
            <param name="value"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:socket4net.DictionaryExt.AddIfNotExist``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
                若指定键不存在，则添加值，并返回true，否则返回false
            </summary>
            <param name="input"></param>
            <param name="key"></param>
            <param name="value"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.Merge``2(System.Collections.Generic.Dictionary{``0,``1},socket4net.Pair{``0,``1})">
            <summary>
                融合两个字典
            </summary>
            <param name="input"></param>
            <param name="pair"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.Merge``1(System.Collections.Generic.Dictionary{``0,``0},socket4net.Pair{``0})">
            <summary>
                将对插入字典
            </summary>
            <param name="input"></param>
            <param name="pair"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.Merge``1(System.Collections.Generic.Dictionary{``0,``0},System.Collections.Generic.List{socket4net.Pair{``0}})">
            <summary>
                将对列表融合进字典
            </summary>
            <param name="input"></param>
            <param name="pairs"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.Merge``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
                将键值插入字典
            </summary>
            <param name="input"></param>
            <param name="key"></param>
            <param name="value"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.DictionaryExt.Merge``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
                融合两个字典
            </summary>
            <param name="input"></param>
            <param name="other"></param>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="T:socket4net.FileSys">
            <summary>
                extension for file system
            </summary>
        </member>
        <member name="M:socket4net.FileSys.Read(System.String)">
            <summary>
                read as text
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)">
            <summary>
                枚举所有文件夹
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateFilesAndDirectories(System.String,System.String,System.IO.SearchOption)">
            <summary>
                枚举所有文件和文件夹
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateFilesRelative(System.String,System.String,System.IO.SearchOption)">
            <summary>
                枚举文件（以相对路径）
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateDirectoriesRelative(System.String,System.String,System.IO.SearchOption)">
            <summary>
                枚举文件夹（以相对路径）
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateFilesAndDirectoriesRelative(System.String,System.String,System.IO.SearchOption)">
            <summary>
                枚举文件和文件夹
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateFilesRelativeWithoutExt(System.String,System.String,System.IO.SearchOption)">
            <summary>
                枚举文件（剔除扩展名）
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateFilesFull(System.String,System.String,System.IO.SearchOption)">
            <summary>
                枚举文件（全路径）
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateDirectoriesFull(System.String,System.String,System.IO.SearchOption)">
            <summary>
                枚举文件夹（全路径）
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.EnumerateFilesAndDirectoriesFull(System.String,System.String,System.IO.SearchOption)">
            <summary>
                枚举文件和文件夹（全路径）
            </summary>
            <param name="dir"></param>
            <param name="searchPattern"></param>
            <param name="searchOption"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.Copy(System.String,System.String,System.Boolean)">
            <summary>
                拷贝文件
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="overwrite"></param>
        </member>
        <member name="M:socket4net.FileSys.CopyDirectory(System.String,System.String,System.Boolean)">
            <summary>
                拷贝路径
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="overwrite"></param>
        </member>
        <member name="M:socket4net.FileSys.DirectoryExists(System.String)">
            <summary>
                是否存在文件夹路径
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.CreateDirectory(System.String,System.Boolean)">
            <summary>
                创建文件夹
            </summary>
            <param name="path"></param>
            <param name="hidden"></param>
        </member>
        <member name="M:socket4net.FileSys.DeleteDirectory(System.String)">
            <summary>
                删除文件夹（递归删除所有子文件夹）
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:socket4net.FileSys.ReadFile(System.String)">
            <summary>
                读文件为文本
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.ReadFileLines(System.String)">
            <summary>
                读文件为字符列表
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.IsPathRooted(System.String)">
            <summary>
                是否为根路径（如 D://, /home/）
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="P:socket4net.FileSys.CurrentDirectory">
            <summary>
                当前工作路径
            </summary>
        </member>
        <member name="P:socket4net.FileSys.NewLine">
            <summary>
            
            </summary>
        </member>
        <member name="M:socket4net.FileSys.GetLastWriteTime(System.String)">
            <summary>
                获取文件最近修改时间
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.Move(System.String,System.String)">
            <summary>
                移动文件
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
        </member>
        <member name="M:socket4net.FileSys.MoveDirectory(System.String,System.String)">
            <summary>
                移动文件夹
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
        </member>
        <member name="M:socket4net.FileSys.FileExists(System.String)">
            <summary>
                文件是否存在
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.FileDelete(System.String)">
            <summary>
                删除文件
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:socket4net.FileSys.SplitLines(System.String)">
            <summary>
                按照换行符拆分字符串为字符数组
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.WriteToFile(System.String,System.String)">
            <summary>
                写文本至文件
            </summary>
            <param name="path"></param>
            <param name="text"></param>
        </member>
        <member name="M:socket4net.FileSys.CreateFileStream(System.String,System.IO.FileMode)">
            <summary>
                创建文件流
            </summary>
            <param name="filePath"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.WriteAllBytes(System.String,System.Byte[])">
            <summary>
                写二进制数据至文件
            </summary>
            <param name="filePath"></param>
            <param name="bytes"></param>
        </member>
        <member name="M:socket4net.FileSys.GetWorkingDirectory(System.String)">
            <summary>
                获取路径的工作路径（文件？返回父目录 ：返回路径）
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.GetFullPath(System.String)">
            <summary>
                获取全路径
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.GetRelativeWorkingDirectory(System.String)">
            <summary>
                获取相对于指定路径的相对路径
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.FileSys.GetNodes(System.String)">
            <summary>
                获取路径中的所有节点
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="P:socket4net.FileSys.WorkingDirectory">
            <summary>
                
            </summary>
        </member>
        <member name="T:socket4net.ListExt">
            <summary>
            extension for list
            </summary>
        </member>
        <member name="M:socket4net.ListExt.ToStringList``1(System.Collections.Generic.List{``0})">
            <summary>
                将输入列表转为字符串列表
            </summary>
            <param name="input"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.ListExt.AddIfNotExist``1(System.Collections.Generic.List{``0},``0)">
            <summary>
                若元素不在列表中，则添加之
            </summary>
            <param name="input"></param>
            <param name="item"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.ListExt.Mult``1(System.Collections.Generic.List{socket4net.Pair{``0}},System.Int32)">
            <summary>
                返回一个新的列表，该列表元素依次为为输入列表的元素乘以n
            </summary>
            <param name="input"></param>
            <param name="n"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.ListExt.Merge(System.Collections.Generic.List{socket4net.Pair{System.Int32}},socket4net.Pair{System.Int32})">
            <summary>
                融合对列表
            </summary>
            <param name="input"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.ListExt.Merge(System.Collections.Generic.List{socket4net.Pair{System.Int32}},System.Collections.Generic.List{socket4net.Pair{System.Int32}})">
            <summary>
                融合两个列表
            </summary>
            <param name="input"></param>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.ListExt.ToPair``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
                拆分列表为对列表
            </summary>
            <param name="input"></param>
            <param name="startIdx"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.ListExt.ToDic``1(System.Collections.Generic.List{socket4net.Pair{``0}})">
            <summary>
                将对列表转为字典
            </summary>
            <param name="input"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.ListExt.Format``1(System.Collections.Generic.List{``0})">
            <summary>
                格式化列表为可读字符串
            </summary>
            <param name="input"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:socket4net.Rand">
            <summary>
                random num generator
            </summary>
        </member>
        <member name="M:socket4net.Rand.NextBoolean">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:socket4net.Rand.Next">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:socket4net.Rand.Next(System.Int32)">
            <summary>
            
            </summary>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Rand.Next(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Rand.Next(System.Int32[])">
            <summary>
                在总长为Sum(input)的线段中随机一个点
                返回随机点所在的区间索引
            
                例如：
                    Next(1, 3, 6)
                    长度为10的线段，以1/3/6为长度连续划分为3段，亦即[0,1),[1,4),[4,10)
                若Next(10)=5，此时5落在第3段，所以返回2
                若Next(10)=1, 则返回0
                若Next(10)=2, 则返回1
                等...
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:socket4net.Rand.Next(System.Int32,System.Int32,System.Int32)">
            <summary>
                [min, max)区间内随机cnt个不重数
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="cnt"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.StringExt">
            <summary>
                字符串扩展
            </summary>
        </member>
        <member name="M:socket4net.StringExt.IsNullOrWhiteSpace(System.String)">
            <summary>
                字符串是否为空或仅包含空格
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.Add`1">
            <summary>
                + 运算
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:socket4net.Add`1.Function">
            <summary>
                返回编译过得+运算表达式
            </summary>
        </member>
        <member name="T:socket4net.Compare`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:socket4net.Compare`1.Function">
            <summary>
                get the compiled function
            </summary>
        </member>
        <member name="T:socket4net.Equals`1">
            <summary>
                = 运算
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:socket4net.Equals`1.Function">
            <summary>
                获取编译过得=表达式
            </summary>
        </member>
        <member name="T:socket4net.GreaterThan`1">
            <summary>
                > 比较符
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:socket4net.LessThan`1">
            <summary>
                小于 比较符
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:socket4net.Multiply`1">
            <summary>
                乘以
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:socket4net.Multiply`1.Function">
            <summary>
                获取编译过得乘以表达式
            </summary>
        </member>
        <member name="T:socket4net.Subtract`1">
            <summary>
                - 运算
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:socket4net.Subtract`1.Function">
            <summary>
                获取编译过的减运算
            </summary>
        </member>
        <member name="T:socket4net.Indefinite`1">
            <summary>
                不确定个数
            </summary>
        </member>
        <member name="T:socket4net.Pair`2">
            <summary>
                pair
            </summary>
            <typeparam name="TFirst"></typeparam>
            <typeparam name="TSecond"></typeparam>
        </member>
        <member name="M:socket4net.Pair`2.#ctor(System.String)">
            <summary>
                constructor
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:socket4net.Pair`2.#ctor(`0,`1)">
            <summary>
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:socket4net.Pair`2.Key">
            <summary>
                first element of pair
            </summary>
        </member>
        <member name="P:socket4net.Pair`2.Value">
            <summary>
                second element of pair
            </summary>
        </member>
        <member name="M:socket4net.Pair`2.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:socket4net.Pair`2.Parse(System.String)">
            <summary>
                从字符串解析键值
            </summary>
            <param name="str"></param>
        </member>
        <member name="T:socket4net.Pair`1">
            <summary>
                generic pair
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.Pair`1.#ctor(System.String)">
            <summary>
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:socket4net.Pair`1.#ctor(`0,`0)">
            <summary>
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:socket4net.Treble`3">
            <summary>
                用于解析诸如 1 2 4 + 3 3 5 + 7 6 9 这种类型的string
            </summary>
        </member>
        <member name="T:socket4net.Uid">
            <summary>
                全局唯一ID生成
            </summary>
        </member>
        <member name="M:socket4net.Uid.Create">
            <summary>
                create an guid
            </summary>
            <returns></returns>
        </member>
        <member name="T:socket4net.TaskHelper">
            <summary>
                .net Task扩展方法
            </summary>
        </member>
        <member name="M:socket4net.TaskHelper.WrapCallback``1(System.Action{System.Action{``0}})">
            <summary>
                 将以回调形式返回的方法包装为一个task
            </summary>
            <param name="fun"></param>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.TaskHelper.WrapCallback``2(``0,System.Action{``0,System.Action{``1}})">
            <summary>
            
            </summary>
            <param name="arg1"></param>
            <param name="fun"></param>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.TaskHelper.WrapCallback``3(``0,``1,System.Action{``0,``1,System.Action{``2}})">
            <summary>
            
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="fun"></param>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.TaskHelper.WrapCallback``4(``0,``1,``2,System.Action{``0,``1,``2,System.Action{``3}})">
            <summary>
            
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="fun"></param>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.TaskHelper.WrapCallback``5(``0,``1,``2,``3,System.Action{``0,``1,``2,``3,System.Action{``4}})">
            <summary>
            
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <param name="fun"></param>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteAsync``1(System.Func{``0})">
            <summary>
                异步执行
            </summary>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteAsync``2(``0,System.Func{``0,``1})">
            <summary>
                异步执行
            </summary>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteAsync``3(``0,``1,System.Func{``0,``1,``2})">
            <summary>
            
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="fun"></param>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteAsync``4(``0,``1,``2,System.Func{``0,``1,``2,``3})">
            <summary>
            
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="fun"></param>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteTask``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
                同步执行一个Task
            </summary>
            <param name="fun"></param>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteTaskAndReturnByCallback``1(System.Func{System.Threading.Tasks.Task{``0}},System.Action{``0})">
            <summary>
            
            </summary>
            <param name="fun"></param>
            <param name="cb"></param>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteTaskAndReturnByCallback``2(``0,System.Func{``0,System.Threading.Tasks.Task{``1}},System.Action{``1})">
            <summary>
            
            </summary>
            <param name="arg1"></param>
            <param name="fun"></param>
            <param name="cb"></param>
            <typeparam name="T1"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteTaskAndReturnByCallback``3(``0,``1,System.Func{``0,``1,System.Threading.Tasks.Task{``2}},System.Action{``2})">
            <summary>
            
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="fun"></param>
            <param name="cb"></param>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="T:socket4net.Coroutine">
            <summary>
                协程
            </summary>
        </member>
        <member name="M:socket4net.Coroutine.#ctor(System.Func{System.Object[],System.Collections.IEnumerator},System.Object[])">
            <summary>
                constructor
            </summary>
            <param name="fun"></param>
            <param name="args"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:socket4net.Coroutine.#ctor(System.Func{System.Collections.IEnumerator})">
            <summary>
                constructor
            </summary>
            <param name="fun"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:socket4net.Coroutine.Update">
            <summary>
                每帧执行一次
            </summary>
            <returns>false表示协程未完毕，反之协程已完毕</returns>
        </member>
        <member name="M:socket4net.Coroutine.Process(System.Collections.IEnumerator)">
            <summary>
                处理枚举器
            </summary>
            <param name="enumerator"></param>
            <returns>
                False表示当前无任务
                True表示还有任务需处理
            </returns>
        </member>
        <member name="T:socket4net.DefaultLogger">
            <summary>
                socket4net's default logger
                with websocket-sharp's logger implementation
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Debug(System.Object)">
            <summary>
                Log as debug level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Debug(System.String,System.Object[])">
            <summary>
                Log as debug level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Error(System.Object)">
            <summary>
                Log as error level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Error(System.String,System.Object[])">
            <summary>
                Log as error level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Fatal(System.Object)">
            <summary>
                Log as fatal level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Fatal(System.String,System.Object[])">
            <summary>
                Log as fatal level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Info(System.Object)">
            <summary>
                Log as information level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Info(System.String,System.Object[])">
            <summary>
                Log as information level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Warn(System.Object)">
            <summary>
                Log as warnning level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Warn(System.String,System.Object[])">
            <summary>
                Log as warnning level
            </summary>
        </member>
        <member name="M:socket4net.DefaultLogger.Exception(System.String,System.Exception)">
            <summary>
                Log exception
            </summary>
            <param name="msg"></param>
            <param name="e"></param>
        </member>
        <member name="M:socket4net.DefaultLogger.Shutdown">
            <summary>
                Destroy logger
            </summary>
        </member>
        <member name="T:socket4net.ILog">
            <summary>
                Logger interface
            </summary>
        </member>
        <member name="M:socket4net.ILog.Debug(System.Object)">
            <summary>
                Log as debug level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Debug(System.String,System.Object[])">
            <summary>
                Log as debug level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Error(System.Object)">
            <summary>
                Log as error level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Error(System.String,System.Object[])">
            <summary>
                Log as error level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Fatal(System.Object)">
            <summary>
                Log as fatal level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Fatal(System.String,System.Object[])">
            <summary>
                Log as fatal level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Info(System.Object)">
            <summary>
                Log as information level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Info(System.String,System.Object[])">
            <summary>
                Log as information level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Warn(System.Object)">
            <summary>
                Log as warnning level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Warn(System.String,System.Object[])">
            <summary>
                Log as warnning level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Exception(System.String,System.Exception)">
            <summary>
                Log exception
            </summary>
            <param name="msg"></param>
            <param name="e"></param>
        </member>
        <member name="M:socket4net.ILog.Shutdown">
            <summary>
                Destroy logger
            </summary>
        </member>
        <member name="T:socket4net.Logger">
            <summary>
                link to logger singlton
            </summary>
        </member>
        <member name="P:socket4net.Logger.Ins">
            <summary>
                instance
            </summary>
        </member>
        <member name="T:socket4net.Mgr`1">
            <summary>
                对象管理器
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:socket4net.Mgr`1.OnDestroy">
            <summary>
               internal called when an Obj is to be destroyed
            </summary>
        </member>
        <member name="M:socket4net.Mgr`1.OnStart">
            <summary>
                Invoked when obj started
            </summary>
        </member>
        <member name="M:socket4net.Mgr`1.OnBorn">
            <summary>
                Invoked when obj born
            </summary>
        </member>
        <member name="M:socket4net.Mgr`1.GetEnumerator">
            <summary>返回一个循环访问集合的枚举数。</summary>
            <returns>可用于循环访问集合的 <see cref="T:System.Collections.Generic.IEnumerator`1" />。</returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:socket4net.Mgr`1.Destroy``1">
            <summary>
             destroy all the elements of type "T"
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.Mgr`1.Destroy``1(System.Predicate{``0})">
            <summary>
             destroy all the elements of type "T" that satisfied the "condition"
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.Mgr`1.Get``1">
            <summary>
             get all the elements of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.Mgr`1.Get``1(System.Predicate{``0})">
            <summary>
             get all the elements of type "T" that satisfied the "condition"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Mgr`1.GetReverse``1">
            <summary>
             get all the elements of type "T" as reverse order
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.Mgr`1.GetFirst``1">
            <summary>
             get the first element of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.Mgr`1.Create``1(socket4net.ObjArg,System.Boolean)">
            <summary>
                create object of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.ObjArg">
            <summary>
                Arguments used to initialize an Obj
            </summary>
        </member>
        <member name="P:socket4net.ObjArg.Owner">
            <summary>
                Owner of to be initialized Obj
            </summary>
        </member>
        <member name="M:socket4net.ObjArg.#ctor(socket4net.IObj)">
            <summary>
                Constructor
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:socket4net.ObjArg.SetOwner(socket4net.IObj)">
            <summary>
                set owner
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:socket4net.ObjArg.Empty">
            <summary>
                Empty obj argument
            </summary>
        </member>
        <member name="M:socket4net.ObjArg.As``1">
            <summary>
                Cast this arg to T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:socket4net.EmptyArg">
            <summary>
                Empty obj argument
            </summary>
        </member>
        <member name="M:socket4net.EmptyArg.#ctor">
            <summary>
                Constructor
            </summary>
        </member>
        <member name="T:socket4net.IObj">
            <summary>
                Interface Obj
            </summary>
        </member>
        <member name="P:socket4net.IObj.InstanceId">
            <summary>
                Obj instance id
                Unique only before current process dead
            </summary>
        </member>
        <member name="P:socket4net.IObj.Owner">
            <summary>
                Owner
            </summary>
        </member>
        <member name="P:socket4net.IObj.Name">
            <summary>
                name
            </summary>
        </member>
        <member name="P:socket4net.IObj.Priority">
            <summary>
                Schedule priority
                Just like Unity's layer
            </summary>
        </member>
        <member name="P:socket4net.IObj.OwnerDescription">
            <summary>
                Owner description
            </summary>
        </member>
        <member name="P:socket4net.IObj.Initialized">
            <summary>
                If initialized
            </summary>
        </member>
        <member name="P:socket4net.IObj.Started">
            <summary>
                If started
            </summary>
        </member>
        <member name="P:socket4net.IObj.Destroyed">
            <summary>
                If destroyed
            </summary>
        </member>
        <member name="P:socket4net.IObj.Fresh">
            <summary>
                If IObj's 'Born' invoked 
            </summary>
        </member>
        <member name="M:socket4net.IObj.CompareTo(socket4net.IObj)">
            <summary>
                comparer
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.Init(socket4net.ObjArg)">
            <summary>
                Initialize
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:socket4net.IObj.Born">
            <summary>
                Born
                Obj only born once during it's life circle
            </summary>
        </member>
        <member name="M:socket4net.IObj.Start">
            <summary>
                Run
            </summary>
        </member>
        <member name="M:socket4net.IObj.Destroy">
            <summary>
                Destroy
            </summary>
        </member>
        <member name="M:socket4net.IObj.GetAncestor``1">
            <summary>
                Get obj's ancestor
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.GetUserData``1">
            <summary>
                Get user data
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.SetUserData(System.Object)">
            <summary>
                Set user data
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:socket4net.IObj.WaitFor(System.UInt32)">
            <summary>
                Create an IEnumerator used in Coroutine scheduler
                to waiting for 'n' ms
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.StopCoroutine(socket4net.Coroutine)">
            <summary>
                Stop 'coroutine'
            </summary>
            <param name="coroutine"></param>
        </member>
        <member name="M:socket4net.IObj.StartCoroutine(System.Func{System.Collections.IEnumerator})">
            <summary>
                Start 'fun' as an coroutine
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.StartCoroutine(System.Func{System.Object[],System.Collections.IEnumerator},System.Object[])">
            <summary>
                Start 'fun' as an coroutine
            </summary>
            <param name="fun"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.ClearTimers">
            <summary>
                clear timers attached on this obj
            </summary>
        </member>
        <member name="M:socket4net.IObj.InvokeRepeating(System.Action,System.UInt32,System.UInt32)">
            <summary>
                Excute 'action' after 'delay' ms for every 'period' ms
            </summary>
        </member>
        <member name="M:socket4net.IObj.Invoke(System.Action,System.UInt32)">
            <summary>
                Excute 'action' after 'delay' ms
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="M:socket4net.IObj.Invoke(System.Action,System.DateTime)">
            <summary>
                Excute 'action' when 'when'
            </summary>
            <param name="action"></param>
            <param name="when"></param>
        </member>
        <member name="M:socket4net.IObj.Invoke(System.Action,System.Int32,System.Int32,System.Int32)">
            <summary>
                Excute 'action' every 'hour:min:s'
            </summary>
            <param name="action"></param>
            <param name="hour"></param>
            <param name="min"></param>
            <param name="s"></param>
        </member>
        <member name="M:socket4net.IObj.Invoke(System.Action,System.TimeSpan)">
            <summary>
                Excute 'action' everyday's 'time' clock
            </summary>
            <param name="action"></param>
            <param name="time"></param>
        </member>
        <member name="M:socket4net.IObj.CancelInvoke(System.Action)">
            <summary>
                Cancel 'action'
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.TimeSpan[])">
            <summary>
                Excute 'action' everyday's 'times' clock
            </summary>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.DateTime[])">
            <summary>
                Excute 'action' when 'whens'
            </summary>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.TimeSpan)">
            <summary>
                Excute 'action' everyday's 'time' clock
            </summary>
            <param name="action"></param>
            <param name="time"></param>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.DateTime)">
            <summary>
                Excute 'action' when 'when'
            </summary>
            <param name="action"></param>
            <param name="when"></param>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.UInt32)">
            <summary>
                Excute 'action' after 'delay' ms
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="T:socket4net.UniqueObjArg`1">
            <summary>
                unique object arguments
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="P:socket4net.UniqueObjArg`1.Key">
            <summary>
             unique key
            </summary>
        </member>
        <member name="M:socket4net.UniqueObjArg`1.#ctor(socket4net.IObj,`0)">
            <summary>
                constructor
            </summary>
            <param name="owner"></param>
            <param name="key"></param>
        </member>
        <member name="T:socket4net.IUniqueObj`1">
            <summary>
                interface of unique object
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="P:socket4net.IUniqueObj`1.Id">
            <summary>
                unique key
            </summary>
        </member>
        <member name="T:socket4net.UniqueObj`1">
            <summary>
                拥有唯一Id（容器内唯一，不一定是Guid）
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="M:socket4net.UniqueObj`1.OnInit(socket4net.ObjArg)">
            <summary>
               internal called when an Obj is initialized
            </summary>
            <param name="arg"></param>
        </member>
        <member name="P:socket4net.UniqueObj`1.Id">
            <summary>
                unique key
            </summary>
        </member>
        <member name="P:socket4net.UniqueObj`1.Name">
            <summary>
                name
            </summary>
        </member>
        <member name="T:socket4net.ObjFactory">
            <summary>
                objects factory
            </summary>
        </member>
        <member name="T:socket4net.AutoWatch">
            <summary>
                Automatic time watcher
            </summary>
        </member>
        <member name="M:socket4net.AutoWatch.#ctor(System.String,System.Int64,System.Action{System.String,System.Int64})">
            <summary>
                constructor
            </summary>
            <param name="name"></param>
            <param name="threhold"></param>
            <param name="handler"></param>
        </member>
        <member name="P:socket4net.AutoWatch.Name">
            <summary>
                Watcher name
            </summary>
        </member>
        <member name="P:socket4net.AutoWatch.Threhold">
            <summary>
                Wather threhold 
                Warnning will be raised when elapsed ms > threhold
            </summary>
        </member>
        <member name="P:socket4net.AutoWatch.Handler">
            <summary>
                Callback when this watch disposed
            </summary>
        </member>
        <member name="M:socket4net.AutoWatch.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:socket4net.AutoWatch.ElapsedMilliseconds">
            <summary>
                Get elapsed ms since this watch constructed
            </summary>
        </member>
        <member name="T:socket4net.LinqExt">
            <summary>
                extension for LINQ
            </summary>
        </member>
        <member name="M:socket4net.LinqExt.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                是否为空
            </summary>
            <param name="enumerable"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.LinqExt.Split``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                分组,对分
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="parts"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.LinqExt.NextRand``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                get next random item from input
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.Value">
            <summary>
                bytes反序列化成Value
            </summary>
        </member>
        <member name="M:socket4net.Value.As``1(System.Byte[])">
            <summary>
                
            </summary>
            <param name="bytes"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:socket4net.ValueProto`1">
            <summary>
                包装一个值以用在序列化
                注意：Value并不是IProtobufInstance
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.ValueProto`1.#ctor">
            <summary>
                for pb
            </summary>
        </member>
        <member name="T:socket4net.PbSerializer">
            <summary>
                基于protobuf的序列化器
                注：尽可能使用泛型接口
            </summary>
        </member>
        <member name="M:socket4net.PbSerializer.Serialize``1(``0)">
            <summary>
                序列化一个protobuf实例
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.PbSerializer.Deserialize``1(System.Byte[])">
            <summary>
                反序列化为一个pb实例
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.PbSerializer.SerializeValue``1(``0)">
            <summary>
                序列化一个值
                比如：int, float, long ...
            </summary>
            <typeparam name="T">值类型</typeparam>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:socket4net.PbSerializer.DeserializeValue``1(System.Byte[])">
            <summary>
                反序列化为值
            </summary>
            <typeparam name="T">List<string/> ...</typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.PbSerializer.Deserialize(System.Type,System.Byte[])">
            <summary>
                非泛型方式的反序列化
                仅用于pb实例
            </summary>
        </member>
        <member name="T:socket4net.LauncherArg">
            <summary>
                launcher arguments
            </summary>
        </member>
        <member name="M:socket4net.LauncherArg.#ctor(System.Boolean,socket4net.ILog,System.Nullable{System.Guid})">
            <summary>
                ctor
            </summary>
            <param name="monitorEnabled">if enable performance monitor</param>
            <param name="logger">logger</param>
            <param name="id">specify guid</param>
        </member>
        <member name="P:socket4net.LauncherArg.Logger">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.LauncherArg.Id">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.LauncherArg.Default">
            <summary>
                return default launcher arguments
            </summary>
        </member>
        <member name="P:socket4net.LauncherArg.MonitorEnabled">
            <summary>
                performance monitor enabled
            </summary>
        </member>
        <member name="T:socket4net.Launcher">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.Launcher.Ins">
            <summary>
                get launcher singlton instance
            </summary>
        </member>
        <member name="P:socket4net.Launcher.Service">
            <summary>
                get logic service
            </summary>
        </member>
        <member name="M:socket4net.Launcher.OnInit(socket4net.ObjArg)">
            <summary>
               internal called when an Obj is initialized
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:socket4net.Launcher.OnStart">
            <summary>
                Invoked when obj started
            </summary>
        </member>
        <member name="M:socket4net.Launcher.OnDestroy">
            <summary>
               internal called when an Obj is to be destroyed
            </summary>
        </member>
        <member name="T:socket4net.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:socket4net.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:socket4net.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface
             and this method is used to notify that some property value changed
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:socket4net.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:socket4net.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:socket4net.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:socket4net.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly
            when marked with <see cref="T:socket4net.Annotations.MeansImplicitUseAttribute"/>
            or <see cref="T:socket4net.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:socket4net.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used
            </summary>
        </member>
        <member name="T:socket4net.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:socket4net.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder
            within a web project. Path can be relative or absolute,
            starting from web root (~)
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC controller. If applied to a method,
            the MVC controller name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, Object)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC partial view. If applied to a method,
            the MVC partial view name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcSupressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling all inspections
            for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>
            </summary>
        </member>
        <member name="T:socket4net.CoroutineScheduler">
            <summary>
                协程调度器
            </summary>
        </member>
        <member name="M:socket4net.CoroutineScheduler.OnInit(socket4net.ObjArg)">
            <summary>
                internal called when an Obj is initialized
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:socket4net.CoroutineScheduler.OnDestroy">
            <summary>
                internal called when an Obj is to be destroyed
            </summary>
        </member>
        <member name="M:socket4net.CoroutineScheduler.InternalStopCoroutine(socket4net.Coroutine)">
            <summary>
            </summary>
            <param name="coroutine"></param>
        </member>
        <member name="M:socket4net.CoroutineScheduler.InternalStartCoroutine(System.Func{System.Collections.IEnumerator})">
            <summary>
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.CoroutineScheduler.InternalStartCoroutine(System.Func{System.Object[],System.Collections.IEnumerator},System.Object[])">
            <summary>
            </summary>
            <param name="fun"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Create``1(socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                创建
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Create(System.Type,socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                非泛型创建
            </summary>
            <param name="type"></param>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Create``1(System.Type,socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                非泛型创建，并cast成T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.CreateDefault``1(socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                创建默认
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.CreateDefault(System.Type,socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                非泛型创建默认
            </summary>
            <param name="type"></param>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.CreateDefault``1(System.Type,socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                非泛型创建默认，并cast成T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.DestroyAll">
            <summary>
                destory all items
            </summary>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Destroy(System.Predicate{`2})">
            <summary>
                destroy items that match "condition"
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Destroy``1">
            <summary>
                destroy all items of type "T"
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Destroy``1(System.Predicate{``0})">
            <summary>
                destroy items of type "T" that match "condition"
            </summary>
            <param name="condition"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Destroy(`1)">
            <summary>
                destroy item specified by "key"
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Destroy(`2)">
            <summary>
                destroy item specified by "value"
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Add(`2)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.UniqueMgr`2">
            <summary>
                对象管理器
                对象之间以id唯一区分
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:socket4net.GlobalVarPool">
            <summary>
                全局变量池
            </summary>
        </member>
        <member name="F:socket4net.GlobalVarPool.NameOfLogicService">
            <summary>
            </summary>
        </member>
        <member name="F:socket4net.GlobalVarPool.NameOfTcpService">
            <summary>
            </summary>
        </member>
        <member name="F:socket4net.GlobalVarPool.NameOfWsService">
            <summary>
            </summary>
        </member>
        <member name="F:socket4net.GlobalVarPool.NameOfLogger">
            <summary>
            </summary>
        </member>
        <member name="F:socket4net.GlobalVarPool.NameOfMonitor">
            <summary>
            </summary>
        </member>
        <member name="P:socket4net.GlobalVarPool.Ins">
            <summary>
                get the singlton instance of the global variables pool
            </summary>
        </member>
        <member name="M:socket4net.GlobalVarPool.Get``1(System.String)">
            <summary>
                get the value of "key" as "T"
            </summary>
            <param name="key"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.GlobalVarPool.Set``1(System.String,``0)">
            <summary>
                set value
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="var"></param>
        </member>
        <member name="P:socket4net.GlobalVarPool.Service">
            <summary>
                get logic service
            </summary>
        </member>
        <member name="P:socket4net.GlobalVarPool.Logger">
            <summary>
                get logger
            </summary>
        </member>
        <member name="P:socket4net.GlobalVarPool.Monitor">
            <summary>
                get monitor
            </summary>
        </member>
        <member name="T:socket4net.RpcPackage">
            <summary>
                rpc package
            </summary>
        </member>
        <member name="P:socket4net.RpcPackage.Type">
            <summary>
                rpc type
                push/request/response
            </summary>
        </member>
        <member name="P:socket4net.RpcPackage.Serial">
            <summary>
                rpc serial number
            </summary>
        </member>
        <member name="P:socket4net.RpcPackage.Data">
            <summary>
                rpc data
            </summary>
        </member>
        <member name="P:socket4net.RpcPackage.Success">
            <summary>
                
            </summary>
        </member>
        <member name="M:socket4net.RpcPackage.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:socket4net.IJob">
            <summary>
                job
            </summary>
        </member>
        <member name="M:socket4net.IJob.Do">
            <summary>
                excute
            </summary>
        </member>
        <member name="T:socket4net.Job">
            <summary>
            
            </summary>
        </member>
        <member name="M:socket4net.Job.#ctor(System.Action)">
            <summary>
            
            </summary>
            <param name="proc"></param>
        </member>
        <member name="M:socket4net.Job.Do">
            <summary>
                excute
            </summary>
        </member>
        <member name="T:socket4net.Job`1">
            <summary>
                job with parameters
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.Job`1.#ctor(System.Action{`0},`0)">
            <summary>
            
            </summary>
            <param name="proc"></param>
            <param name="param"></param>
        </member>
        <member name="M:socket4net.Job`1.Do">
            <summary>
                excute
            </summary>
        </member>
        <member name="T:socket4net.IWebsocketDelegateHost">
            <summary>
                websocket delegate host
            </summary>
        </member>
        <member name="M:socket4net.IWebsocketDelegateHost.Close">
            <summary>
                close session
            </summary>
        </member>
        <member name="M:socket4net.IWebsocketDelegateHost.SendAsync(System.Byte[],System.Action{System.Boolean})">
            <summary>
                send async
            </summary>
            <param name="bytes"></param>
            <param name="cb"></param>
        </member>
        <member name="M:socket4net.IWebsocketDelegateHost.Send(System.Byte[])">
            <summary>
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:socket4net.IWebsocketDelegateHost.OnRequest(socket4net.IDataProtocol)">
            <summary>
                request handler
            </summary>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.IWebsocketDelegateHost.OnPush(socket4net.IDataProtocol)">
            <summary>
                push handler
            </summary>
            <param name="dp"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.IWebsocketDelegateServerHost">
            <summary>
                websocket delegate server host
            </summary>
        </member>
        <member name="M:socket4net.IWebsocketDelegateServerHost.BroadcastAsync(System.Byte[],System.Action)">
            <summary>
                broadcast async
            </summary>
            <param name="bytes"></param>
            <param name="cb"></param>
        </member>
        <member name="T:socket4net.WebsocketDelegate`1">
            <summary>
                websocket session delegate
            </summary>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.#ctor(`0)">
            <summary>
            </summary>
            <param name="host"></param>
        </member>
        <member name="P:socket4net.WebsocketDelegate`1.DataParser">
            <summary>
                Get/Set custom data parser
            </summary>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.OnMessage(WebSocketSharp.MessageEventArgs)">
            <summary>
                Called when the <see cref="T:WebSocketSharp.WebSocket" /> used in the current session receives a message.
            </summary>
            <param name="e">
                A <see cref="T:WebSocketSharp.MessageEventArgs" /> that represents the event data passed to
                a <see cref="!:WebSocket.OnMessage" /> event.
            </param>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.OnError(WebSocketSharp.ErrorEventArgs)">
            <summary>
                Called when the <see cref="T:WebSocketSharp.WebSocket" /> used in a session gets an error.
            </summary>
            <param name="e">
                A <see cref="T:WebSocketSharp.ErrorEventArgs" /> that represents the event data passed to
                a <see cref="E:WebSocketSharp.WebSocket.OnError" /> event.
            </param>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.OnClose(WebSocketSharp.CloseEventArgs)">
            <summary>
                Called when the WebSocket connection used in a session has been closed.
            </summary>
            <param name="e">
                A <see cref="T:WebSocketSharp.CloseEventArgs" /> that represents the event data passed to
                a <see cref="E:WebSocketSharp.WebSocket.OnClose" /> event.
            </param>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.MultiCast``1(``0,System.Collections.Generic.IEnumerable{socket4net.WebsocketSession})">
            <summary>
                multicast
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
            <param name="sessions"></param>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.RequestAsync``1(``0)">
            <summary>
                request an data protocol asynchronous
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.RequestAsync``1(``0,System.Action{System.Boolean,System.Byte[]})">
            <summary>
            </summary>
            <param name="proto"></param>
            <param name="cb"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.Push``1(``0)">
            <summary>
            </summary>
            <param name="proto"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.RequestAsync(System.UInt16,socket4net.RpcPackage)">
            <summary>
                request asynchronous
                ordered by "serial"
            </summary>
            <param name="serial"></param>
            <param name="pack"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.OnMessage(System.String)">
            <summary>
                string handler
            </summary>
            <param name="data"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.OnMessage(System.Byte[])">
            <summary>
                bytes handler
            </summary>
            <param name="data"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.BroadcastAsync(System.Byte[])">
            <summary>
                asynchronous broadcast bytes
                thread safe
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.BroadcastAsync``1(``0)">
            <summary>
                asynchronous broadcast a proto
            </summary>
            <param name="proto"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.SendAsync(System.Byte[])">
            <summary>
                send bytes asynchronous
                thread safe
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.WebsocketDelegate`1.SendAsync``1(``0)">
            <summary>
                send a proto asynchronous
            </summary>
            <param name="proto"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
    </members>
</doc>
